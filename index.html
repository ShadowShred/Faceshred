// Load models only once
async function loadModelsOnce(){
  if(loadModelsOnce._done) return;
  const base='https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
  await faceapi.nets.tinyFaceDetector.loadFromUri(base);
  loadModelsOnce._done=true;
}

// Detect faces with fallbacks

detectBtn.addEventListener('click', async () => {
    if (!S.image) return;
    facesList.textContent = 'Detecting faces…';

    // 1) Try TinyFaceDetector with device-tuned params
    await loadModelsOnce();
    const mobile = window.innerWidth < 900;
    let opts = new faceapi.TinyFaceDetectorOptions({
      inputSize: mobile ? 416 : 608,
      scoreThreshold: mobile ? 0.28 : 0.25,
    });

    // Try on canvas first
    let dets = await faceapi.detectAllFaces(canvas, opts);

    // 2) If no faces, retry with higher sensitivity and bigger input
    if (!dets.length) {
      facesList.textContent = 'No faces yet — retrying with higher sensitivity…';
      opts = new faceapi.TinyFaceDetectorOptions({ inputSize: mobile ? 512 : 768, scoreThreshold: 0.18 });
      dets = await faceapi.detectAllFaces(canvas, opts);
    }

    // Optional: if still nothing, try the original image element (bypasses canvas scaling issues)
    if (!dets.length) {
      try { dets = await faceapi.detectAllFaces(S.image, opts); } catch {}
    }

    // 3) If still nothing, fall back to SSD Mobilenet v1 (often better on tilted/low-light shots)
    if (!dets.length) {
      try {
        facesList.textContent = 'Still nothing — trying alternate model…';
        const base = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
        if (!faceapi.nets.ssdMobilenetv1 || !faceapi.nets.ssdMobilenetv1.params) {
          await faceapi.nets.ssdMobilenetv1.loadFromUri(base);
        }
        const ssdOpts = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.2, maxResults: 50 });
        dets = await faceapi.detectAllFaces(canvas, ssdOpts);
      } catch (e) {
        console.warn('SSD fallback failed', e);
      }
    }

    if (!dets.length) {
      facesList.textContent = 'No faces detected. Try front-facing shots, better lighting, or rotate/zoom and retry.';
      S.detections = [];
      drawBoxes();
      return;
    }

    // Map + pad boxes
    const pad = parseInt(boxPad.value || '0', 10) / 100;
    S.detections = dets.map(d => {
      const { x, y, width, height } = d.box;
      const dx = width * pad, dy = height * pad;
      const bx = Math.max(0, x - dx);
      const by = Math.max(0, y - dy);
      const bw = Math.min(canvas.width - bx, width + 2 * dx);
      const bh = Math.min(canvas.height - by, height + 2 * dy);
      return { box: { x: bx, y: by, w: bw, h: bh }, selected: true };
    });

    drawBoxes();
    list();
  });
  const mobile = window.innerWidth < 900;
  let opts = new faceapi.TinyFaceDetectorOptions({
    inputSize: mobile ? 416 : 608,
    scoreThreshold: mobile ? 0.28 : 0.25,
  });

  let dets = await faceapi.detectAllFaces(canvas, opts);

  if (!dets.length) {
    facesList.textContent = 'No faces yet — retrying with higher sensitivity…';
    opts = new faceapi.TinyFaceDetectorOptions({
      inputSize: mobile ? 512 : 768,
      scoreThreshold: 0.18,
    });
    dets = await faceapi.detectAllFaces(canvas, opts);
  }

  if (!dets.length) {
    try {
      dets = await faceapi.detectAllFaces(S.image, opts);
    } catch {}
  }

  if (!dets.length) {
    try {
      facesList.textContent = 'Still nothing — trying alternate model…';
      const base='https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
      if (!faceapi.nets.ssdMobilenetv1 || !faceapi.nets.ssdMobilenetv1.params) {
        await faceapi.nets.ssdMobilenetv1.loadFromUri(base);
      }
      const ssdOpts = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.2, maxResults: 50 });
      dets = await faceapi.detectAllFaces(canvas, ssdOpts);
    } catch (e) {
      console.warn('SSD fallback failed', e);
    }
  }

  if (!dets.length) {
    facesList.textContent = 'No faces detected. Try front-facing shots, better lighting, or rotate/zoom and retry.';
    S.detections = [];
    drawBoxes();
    return;
  }

  const pad = parseInt(boxPad.value || '0', 10) / 100;
  S.detections = dets.map(d => {
    const { x, y, width, height } = d.box;
    const dx = width * pad, dy = height * pad;
    const bx = Math.max(0, x - dx);
    const by = Math.max(0, y - dy);
    const bw = Math.min(canvas.width - bx, width + 2 * dx);
    const bh = Math.min(canvas.height - by, height + 2 * dy);
    return { box: { x: bx, y: by, w: bw, h: bh }, selected: true };
  });

  drawBoxes();
  list();
});


